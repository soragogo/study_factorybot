# Next.js 入門 03 - Stateとインタラクティブ機能（詳細版） 📘

## 1. 前提：Server vs Client Components
Next.js (App Router) には2種類のレンダリング環境がある。

| 種類 | Server Component (デフォルト) | Client Component |
| :--- | :--- | :--- |
| **場所** | サーバー側で実行 | ブラウザ（とサーバー）で実行 |
| **役割** | データ取得、静的HTML生成 | ユーザー操作、状態管理、ブラウザAPI利用 |
| **制約** | `useState`, `useEffect` は**使えない** | ファイル先頭に **`"use client";`** が必要 |

> **Note:** `useState` などのフックを使う場合は、必ず `"use client";` 宣言が必要。

---

## 2. useState フックの仕組み

Reactにおける「状態（State）」を管理するための関数。

```tsx
import { useState } from 'react';
const [count, setCount] = useState(0);
```

### 2.1. 引数 (Parameters)

* **初期値 (Initial State)**: `useState(0)` の `0` の部分。
* コンポーネントが**最初にレンダリングされた時だけ**使われる。

### 2.2. 返り値 (Return Value)

`useState` は、常に **要素が2つ入った配列 (Array)** を返す。

| インデックス | 内容 | 型 (TypeScript) | 説明 |
| --- | --- | --- | --- |
| `0` (1番目) | **現在の状態** | `T` (初期値と同じ) | 現在保持している値。読み取り専用として扱う。 |
| `1` (2番目) | **更新関数** | `(value: T) => void` | 状態を更新し、**再レンダリングをトリガーする**関数。 |

---

## 3. JavaScript の構文：分割代入 (Destructuring Assignment)

`const [count, setCount] = ...` という書き方は、React固有のものではなく、JavaScriptの標準機能。
配列の中身を、**順番通りに変数に割り当てる** 記述方法。

### 仕組みの解剖

もし分割代入を使わずに書くと、こうなる（冗長な書き方）：

```javascript
// useStateは配列 [今の値, 更新関数] を返す
const stateArray = useState(0);

const count = stateArray[0];     // 1番目を取り出す
const setCount = stateArray[1];  // 2番目を取り出す

```

これを1行で書くためのショートカットが「分割代入」：

```javascript
// 左側の変数名は自由に決められる（順番が重要）
const [count, setCount] = useState(0);

```

---

## 4. 再レンダリングのサイクル (Re-rendering Cycle)

なぜ変数が `const` (定数) なのに、値が変わるのか？
それは、**「値が書き換わっている」のではなく、「関数コンポーネントが何度も実行し直されている」から**である。

1. **初期表示**: `useState(0)` が呼ばれ、`count` は `0` になる。
2. **イベント**: ユーザーがボタンを押して `setCount(1)` を実行。
3. **トリガー**: Reactが「データが変わったな。画面を作り直そう」と判断。
4. **再実行**: `Home()` 関数が**もう一度最初から実行される**。
5. **記憶の復元**: 今回の `useState(0)` は、Reactの内部メモリから**最新の値（1）**を取り出して返す。
* この時、`const count` には新しい `1` が代入される（新しいスコープ）。


6. **描画**: 新しい `count` を使ってHTML（JSX）を返す。

---

## 5. TypeScript との連携 (型推論)

TypeScriptは初期値を見て、自動的に型を決めてくれる（型推論）。

```tsx
// 推論: number型になる
const [count, setCount] = useState(0);

// 推論: boolean型になる
const [isOpen, setIsOpen] = useState(false);

```

### 明示的な型定義 (Generics)

初期値が `null` の場合や、複雑なオブジェクトの場合は、ジェネリクス `< >` を使う。

```tsx
type User = { name: string; age: number };

// user は "User型" または "null" になる
const [user, setUser] = useState<User | null>(null);

```

---

*Date: 2026-01-10*
